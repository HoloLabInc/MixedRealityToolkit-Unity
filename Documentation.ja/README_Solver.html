<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Solvers (&#12477;&#12523;&#12496;&#12540;) | Mixed Reality Toolkit Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Solvers (&#12477;&#12523;&#12496;&#12540;) | Mixed Reality Toolkit Documentation ">
    <meta name="generator" content="docfx 2.48.0.0">
    
    <link rel="shortcut icon" href=".././Documentation/Images/favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-177859076-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-177859076-1');
    </script>
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src=".././Documentation/Images/mrt_logo_icon.png" alt="">
              </a>
            </div>
          
          <div class="version-dropdown" id="versionDropdown">
           </div>
         
          <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="solvers-ソルバー">Solvers (ソルバー)</h1>

<p><img src="../Documentation/Images/Solver/MRTK_Solver_Main.png" alt="Solver"></p>
<p>Solvers(ソルバー) は、事前に定義されたアルゴリズムにしたがってオブジェクトの位置と回転の計算方法を容易にするコンポーネントです。一つの例として、ユーザーのゲイズ レイキャストが現在当たっている面にオブジェクトをを配置するということが挙げられます。</p>
<p>さらに、Unity にはコンポーネントの update 順を指定するための信頼できる方法はありませんが、ソルバー システムはこれらの移動の計算順序を確定的に定義しています。</p>
<p>ソルバーは、オブジェクトを他のオブジェクトやシステムにくっつけるための幅広い振る舞いを提供しています。他の例として、（カメラを基準として）ユーザーの前に浮かぶタグアロング オブジェクトがあります。ソルバーはオブジェクトをコントローラーに追従させるために、コントローラーとオブジェクトにアタッチすることもできます。全てのソルバーは安全に積み重ねることができます。例えば、タグアロング + surface magnetism + momentum と組み合わせられます。</p>
<h2 id="solver-ソルバー-の使い方">Solver (ソルバー) の使い方</h2>
<p>ソルバー システムは、3つのカテゴリーのスクリプトから構成されています:</p>
<ul>
<li><a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver.html"><code>Solver</code></a>: 全てのソルバーが継承する、ベースとなる abstract class です。状態トラッキング、スムーズにするためのパラメーターと実装、自動的なソルバー システムの統合、そしてアップデート順序を提供しています。</li>
<li><a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler.html"><code>SolverHandler</code></a>: 追跡する参照オブジェクト (例えば、メイン カメラのトランスフォーム、ハンド レイなど) を設定し、ソルバー コンポーネントを集めて適切な順序で更新を実行します。</li>
</ul>
<p>3つめのカテゴリーはソルバー自身です。以下のソルバーは、基本的な動作のためのビルディング ブロックを提供しています。</p>
<ul>
<li><a href="#orbital"><code>Orbital</code></a>: 参照オブジェクトから、指定された位置とオフセットを持った場所に固定します。</li>
<li><a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize.html"><code>ConstantViewSize</code></a>: 参照オブジェクトから見て、一定のサイズを保つように大きさを変えます。</li>
<li><a href="#radialview"><code>RadialView</code></a>: 参照オブジェクトからみて、オブジェクトが視野の中に入るようにします。</li>
<li><a href="#surfacemagnetism"><code>SurfaceMagnetism</code></a>: ワールドの面にレイを飛ばし、オブジェクトをその面に合わせます。</li>
<li><a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum.html"><code>Momentum</code></a>: 他のソルバーやコンポーネントによって動かされるオブジェクトに対して、運動量や弾性をシミュレーションするために、加速度、速度、摩擦を適用します。</li>
<li><a href="#inbetween"><code>InBetween</code></a>: オブジェクトが2つのトラックされたオブジェクトの間にあるように保ちます。</li>
<li><a href="#hand-menu-with-handconstraint-and-handconstraintpalmup"><code>HandConstraint</code></a>: オブジェクトが、ハンドと交差しない領域内でハンドを追従するように制約します。メニューなどの、ハンドに拘束されたインタラクティブなコンテンツに便利です。このソルバーは <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand.html">IMixedRealityHand</a> とともに動作するよう意図されていますが、<a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Input.IMixedRealityController.html">IMixedRealityController</a> とも動作します。</li>
<li><a href="#hand-menu-with-handconstraint-and-handconstraintpalmup"><code>HandConstraintPalmUp</code></a>: HandConstraint から派生していますが、有効化の前に手のひらがユーザーを向いているかをテストするロジックが含まれています。このソルバーは <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand.html">IMixedRealityHand</a> コントローラーでのみ動作し、他のコントローラー タイプについては、このソルバーは基底クラスと全く同じ動作をします。</li>
</ul>
<p>ソルバー システムを使うためには、上記コンポーネントの一つをゲームオブジェクトに単に追加するだけです。全てのソルバーは <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler.html"><code>SolverHandler</code></a> を必要とするため、<a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler.html"><code>SolverHandler</code></a> は Unity によって自動的に作成されます。</p>
<div class="NOTE">
<h5>Note</h5>
<p>ソルバー システムの使い方の例は、<strong>SolverExamples.scene</strong> ファイルにて見つけることができます。</p>
</div>
<h2 id="追跡参照を変更する方法">追跡参照を変更する方法</h2>
<p><a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler.html"><code>SolverHandler</code></a> コンポーネントの <em>Tracked Target Type</em> プロパティは、全てのソルバーがアルゴリズムを計算するときに使用する参照点を定義します。例えば、シンプルな <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism.html"><code>SurfaceMagnetism</code></a> コンポーネントとともに <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.html#Microsoft_MixedReality_Toolkit_Utilities_TrackedObjectType_Head"><code>Head</code></a> が指定された場合、頭からユーザーのゲイズ方向へのレイキャストが、どの面にヒットするかを解決するために使われます。<code>TrackedTargetType</code> プロパティに設定可能な値は以下の通りです。</p>
<ul>
<li><em>Head</em> : 参照点はメイン カメラのトランスフォーム</li>
<li><em>ControllerRay</em>: 参照点は、ライン レイの方向を指しているコントローラーの <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Input.LinePointer.html"><code>LinePointer</code></a> のトランスフォーム(すなわち、モーション コントローラーやハンド コントローラーのポインター原点)。
<ul>
<li>どちらの手（左手、右手、両手）を優先するかを選択するには、<code>TrackedHandedness</code> プロパティを使用します。</li>
</ul>
</li>
<li><em>HandJoint</em>: 参照点は特定のハンド ジョイントのトランスフォーム
<ul>
<li>どちらの手（左手、右手、両手）を優先するかを選択するには、<code>TrackedHandedness</code> プロパティを使用します。</li>
<li>利用するジョイントのトランスフォームを決定するには、<code>TrackedHandJoint</code> プロパティを使用します。</li>
</ul>
</li>
<li><em>CustomOverride</em>: アサインされた <code>TransformOverride</code> からの参照点</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p><em>ControllerRay</em> と <em>HandJoint</em> タイプの両方について、<code>TrackedHandedness</code> プロパティが <code>Both</code> の場合、ソルバー ハンドラーは左のコントローラー/ハンドのトランスフォームを提供しようとし、左が利用できなければ右の値を提供しようとします。</p>
</div>
<p><img src="../Documentation/Images/Solver/TrackedObjectType-Example.gif" alt="Solver"><br>
<em>TrackedTargetType に関連するさまざまなプロパティの例</em></p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>多くのソルバーは <code>SolverHandler</code> によって提供される tracked transform target (追跡するトランスフォーム ターゲット) の forward vector を使用します。<em>Hand Joint</em> のターゲット追跡タイプを使うとき、手のひらのジョイントの forward vector は手のひらをつき抜ける方向ではなく、指の方向を向くかもしれません。これは、プラットフォームが提供する手のジョイント データによります。入力シミュレーションと Windows Mixed Reality では、<em>up vector</em> が手のひらをつき抜ける向き (緑色の vectorが up, 青色の vector が forward) です。</p>
<p><img src="../Documentation/Images/Solver/HandJoint_ForwardUpVectors.png" alt="Solver"></p>
<p>これを解決するため、<code>SolverHandler</code> の <em>Additional Rotation</em> プロパティを <strong>&lt;90, 0, 0&gt;</strong> に更新します。これにより、ソルバーに提供される forward ベクターが手のひらをつき抜けて手の外側へと向くようになります。</p>
<p><img src="../Documentation/Images/Solver/SolverHandler_AdditionalRotation.png" alt="Solver"></p>
<p>あるいは、<em>Controller Ray</em> のターゲット追跡タイプを使うことで、似たようなふるまいをさせることもできます。</p>
</div>
<h2 id="solver-ソルバー-を連鎖させる方法">Solver (ソルバー) を連鎖させる方法</h2>
<p>複数の <code>Solver</code> コンポーネントを同じゲームオブジェクトに追加し、アルゴリズムを連鎖させることが可能です。<code>SolverHandler</code> コンポーネントは、同じゲームオブジェクト上のすべてのソルバーの更新を取り扱います。デフォルトでは <code>SolverHandler</code> は Start で <code>GetComponents&lt;Solver&gt;()</code> を呼び出し、これはインスペクターで表示される順序でソルバーを返します。
さらに、<em>Updated Linked Transform</em> プロパティを true に設定すると、<code>Solver</code> は計算した位置、姿勢、スケールをすべてのソルバー(すなわち、 <code>GoalPosition</code>)からアクセスできる仲介変数に保存します。false の場合は、<code>Solver</code> はゲームオブジェクトのトランスフォームを直接更新します。トランスフォームのプロパティを仲介の場所に保存すると、他のソルバーがその仲介変数から計算を始めることができます。この理由は、Unity は gameObject.transform を同じフレーム内にスタックして更新することを許容していないからです。</p>
<div class="NOTE">
<h5>Note</h5>
<p>開発者は、<code>SolverHandler.Solvers</code> プロパティを直接設定することでソルバーの実行順序を変更することができます。</p>
</div>
<h2 id="新しい-solver-ソルバー-の作り方">新しい Solver (ソルバー) の作り方</h2>
<p>すべてのソルバーは抽象基底クラスである <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver.html"><code>Solver</code></a> を継承しなければなりません。Solver の拡張に主に必要となるのは、<code>SolverUpdate</code> メソッドのオーバーライドに関するものです。このメソッドで、開発者は継承された <code>GoalPosition</code>、<code>GoalRotation</code>、<code>GoalScale</code> プロパティを望ましい値に更新すべきです。さらに、<code>SolverHandler.TransformTarget</code> を、利用者が望む参照座標系として利用すると、たいていの場合に役に立つでしょう。</p>
<p>以下のコードは、<code>InFront</code> という新しいソルバー コンポーネントの例です。これは、アタッチされたオブジェクトを <code>SolverHandler.TransformTarget</code> の前 2m の位置に配置します。もし、<code>SolverHandler.TrackedTargetType</code> が <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.html#Microsoft_MixedReality_Toolkit_Utilities_TrackedObjectType_Head"><code>Head</code></a> に設定された場合、<code>SolverHandler.TransformTarget</code> はカメラのトランスフォームとなり、このソルバーはすべてのフレームでアタッチされたゲームオブジェクトユーザーのゲイズの前 2m の位置に配置します。</p>
<pre><code class="lang-c#">/// &lt;summary&gt;
/// InFront ソルバーは追跡されるトランスフォーム ターゲットの前 2 m の位置にオブジェクトを配置します
/// &lt;/summary&gt;
public class InFront : Solver
{
    ...

    public override void SolverUpdate()
    {
        if (SolverHandler != null &amp;&amp; SolverHandler.TransformTarget != null)
        {
            var target = SolverHandler.TransformTarget;
            GoalPosition = target.position + target.forward * 2.0f;
        }
    }
}
</code></pre>
<h2 id="solver-implementation-guides">Solver implementation guides</h2>
<h3 id="common-solver-properties">Common Solver properties</h3>
<p>Every Solver component has a core-set of identical properties that control the core Solver behavior.</p>
<p>If <em>Smoothing</em> is enabled, then the Solver will gradually update the transform of the GameObject over time to the calculated values. The speed of this change is determined by every transform component's <em>LerpTime</em> property. For example, a higher <em>MoveLerpTime</em> value will result in slower increments in movement between frames.</p>
<p>If <em>MaintainScale</em> is enabled, then the Solver will utilize the GameObject's default local scale.</p>
<p><img src="../Documentation/Images/Solver/GeneralSolverProperties.png" alt="Core Solver Properties"><br>
<em>Common properties inherited by all Solver components</em></p>
<h3 id="orbital">Orbital</h3>
<p>The <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital.html"><code>Orbital</code></a> class is a tag-along component that behaves like planets in a solar system. This Solver will ensure the attached GameObject orbits around the tracked transform. Thus, if the <em>Tracked Target Type</em> of the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler.html"><code>SolverHandler</code></a> is set to <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.html#Microsoft_MixedReality_Toolkit_Utilities_TrackedObjectType_Head"><code>Head</code></a>, then the GameObject will orbit around the user's head with a fixed offset applied.</p>
<p>Developers can modify this fixed offset to keep menus or other scene components at eye-level or at waist level etc. around a user. This is done by modifying the <em>Local Offset</em> and <em>World Offset</em> properties. The <em>Orientation Type</em> property determines the rotation applied to the object if it should maintain it's original rotation or always face the camera or face whatever transform is driving it's position etc.</p>
<p><img src="../Documentation/Images/Solver/OrbitalExample.png" alt="Orbital Example"><br>
<em>Orbital example</em></p>
<h3 id="radialview">RadialView</h3>
<p>The <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView.html"><code>RadialView</code></a> is another tag-along component that keeps a particular portion of a GameObject within the frustum of the user's view.</p>
<p>The <em>Min &amp; Max View Degrees</em> properties determines how large of a portion of the GameObject must always be in view.</p>
<p>The <em>Min &amp; Max Distance</em> properties determines how far the GameObject should be kept from the user. For example, walking towards the GameObject with a <em>Min Distance</em> of 1m will push the GameObject away to ensure it is never closer than 1m to the user.</p>
<p>Generally, the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView.html"><code>RadialView</code></a> is used in conjunction with <em>Tracked Target Type</em> set to <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.html#Microsoft_MixedReality_Toolkit_Utilities_TrackedObjectType_Head"><code>Head</code></a> so that the component follows the user's gaze. However, this component can function to be kept in <em>&quot;view&quot;</em> of any <em>Tracked Target Type</em>.</p>
<p><img src="../Documentation/Images/Solver/RadialViewExample.png" alt="RadialView Example"><br>
<em>RadialView example</em></p>
<h3 id="inbetween">InBetween</h3>
<p>The <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween.html"><code>InBetween</code></a> class will keep the attached GameObject between two transforms. These two transform endpoints are defined by the GameObject's own <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler.html"><code>SolverHandler</code></a> <em>Tracked Target Type</em> and the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween.html"><code>InBetween</code></a> component's <em>Second Tracked Target Type</em> property. Generally, both types will be set to <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.html#Microsoft_MixedReality_Toolkit_Utilities_TrackedObjectType_CustomOverride"><code>CustomOverride</code></a> and the resulting <code>SolverHandler.TransformOverride</code> and <code>InBetween.SecondTransformOverride</code> values set to the two tracked endpoints.</p>
<p>At runtime, the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween.html"><code>InBetween</code></a> component will create another <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler.html"><code>SolverHandler</code></a> component based on the <em>Second Tracked Target Type</em> and <em>Second Transform Override</em> properties.</p>
<p>The <code>PartwayOffset</code> defines where along the line between two transforms the object shall be placed with 0.5 as halfway, 1.0 at the first transform, and 0.0 at the second transform.</p>
<p><img src="../Documentation/Images/Solver/InBetweenExample.png" alt="InBetween Example"><br>
<em>Example of using InBetween solver to keep object between two transforms</em></p>
<h3 id="surfacemagnetism">SurfaceMagnetism</h3>
<p>The <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism.html"><code>SurfaceMagnetism</code></a> works by performing a raycast against a set LayerMask of surfaces and placing the GameObject at that point of contact.</p>
<p>The <em>Surface Normal Offset</em> will place the GameObject a set distance in meters away from the surface in the direction of the normal at the hit point on the surface.</p>
<p>Conversely, the <em>Surface Ray Offset</em> will place the GameObject a set distance in meters away from the surface but in the opposite direction of the raycast performed. Thus, if the raycast is the user's gaze, then the GameObject will move closer along the line from the hit point on the surface to the camera.</p>
<p>The <em>Orientation Mode</em> determines the type of rotation to apply in relation to the normal on the surface.</p>
<ul>
<li><em>None</em> - No rotation applied</li>
<li><em>TrackedTarget</em> - Object will face the tracked transform driving the raycast</li>
<li><em>SurfaceNormal</em> - Object will align based on normal at hit point on surface</li>
<li><em>Blended</em> - Object will align based on normal at hit point on surface AND based on facing the tracked transform.</li>
</ul>
<p>To force the associated GameObject to stay vertical in any mode other than <em>None</em>, enable <em>Keep Orientation Vertical</em>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Use the <em>Orientation Blend</em> property to control the balance between rotation factors when <em>Orientation Mode</em> is set to <em>Blended</em>. A value of 0.0 will have orientation entirely driven by <em>TrackedTarget</em> mode and a value of 1.0 will have orientation driven entirely by <em>SurfaceNormal</em>.</p>
</div>
<p><img src="../Documentation/Images/Solver/SurfaceMagExample.png" alt="SurfaceMagnetism Example"></p>
<h4 id="determining-what-surfaces-can-be-hit">Determining what surfaces can be hit</h4>
<p>When adding a <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism.html"><code>SurfaceMagnetism</code></a> component to a GameObject, it is important to consider the layer of the GameObject and it's children, if any have colliders. The component works by performing various types of raycasts to determine what surface to &quot;magnet&quot; itself against. If the solver GameObject has a collider on one of the layers listed in the <code>MagneticSurfaces</code> property of <code>SurfaceMagnetism</code>, then the raycast will likely hit itself resulting in the GameObject attaching to it's own collider point. This odd behavior can be avoided by setting the main GameObject and all children to the <em>Ignore Raycast</em> layer or modifying the <code>MagneticSurfaces</code> LayerMask array appropriately.</p>
<p>Conversely, a <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism.html"><code>SurfaceMagnetism</code></a> GameObject will not collide with surfaces on a layer not listed in the <code>MagneticSurfaces</code> property. It is generally recommended to place all desired surfaces on a dedicated layer (i.e <em>Surfaces</em>) and setting the <code>MagneticSurfaces</code> property to just this layer.  Using <em>default</em> or <em>everything</em> may result in UI components or cursors contributing to the solver.</p>
<p>Finally, surfaces farther than the <code>MaxRaycastDistance</code> property setting will be ignored by the <code>SurfaceMagnetism</code> raycasts.</p>
<h3 id="hand-menu-with-handconstraint-and-handconstraintpalmup">Hand Menu with HandConstraint and HandConstraintPalmUp</h3>
<p><img src="../Documentation/Images/Solver/MRTK_UX_HandMenu.png" alt="Hand Menu UX Example"></p>
<p>The <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint.html"><code>HandConstraint</code></a> behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc). Safe regions are considered areas that don't intersect with the hand. A derived class of <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint.html"><code>HandConstraint</code></a> called <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp.html"><code>HandConstraintPalmUp</code></a> is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</p>
<p><a href="README_HandMenu.html">Please see Hand Menu page</a> for the examples of using Hand Constraint solver to create hand menus.</p>
<h2 id="experimental-solvers">Experimental Solvers</h2>
<p>These solvers are available in MRTK but are currently experimental. Their APIs and functionality are subject to change. Furthermore, their robustness and quality may be lower than standard features.</p>
<h3 id="directional-indicator">Directional Indicator</h3>
<p>The <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Experimental.Utilities.DirectionalIndicator.html"><code>DirectionalIndicator</code></a> class is a tag-along component that orients itself to the direction of a desired point in space.</p>
<p>Most commonly used when the <em>Tracked Target Type</em> of the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler.html"><code>SolverHandler</code></a> is set to <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.html#Microsoft_MixedReality_Toolkit_Utilities_TrackedObjectType_Head"><code>Head</code></a>. In this fashion, a UX component with the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Experimental.Utilities.DirectionalIndicator.html"><code>DirectionalIndicator</code></a>  solver will direct a user to look at the desired point in space.</p>
<p>The desired point in space is determined via the <em>Directional Target</em> property.</p>
<p>If the directional target is viewable by the user, or whatever frame of reference is set in the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler.html"><code>SolverHandler</code></a>, then this solver will disable all <a href="https://docs.unity3d.com/ScriptReference/Renderer.html"><code>Renderer</code></a> components underneath it. If not viewable, then everything will be enabled on the indicator.</p>
<ul>
<li><em>Visibility Scale Factor</em> - Multiplier to increase or decrease the FOV that determines if the <em>Directional Target</em> point is viewable or not</li>
<li><em>View Offset</em> - From the viewpoint of the frame of reference (i.e camera possibly), this property defines how far in the indicator direction should the object be from the center of the viewport.</li>
</ul>
<p><img src="../Documentation/Images/Solver/DirectionalIndicatorExample.png" alt="Directional Indicator properties"><br>
<em>Directional Indicator properties</em></p>
<p><img src="../Documentation/Images/Solver/DirectionalIndicatorExampleScene.gif" alt="Directional Indicator example scene"></p>
<p><em>Directional Indicator Example Scene (Assets/MRTK/Examples/Experimental/Solvers/DirectionalIndicatorExample.unity)</em></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Input/HandTracking.html">Hand Tracking</a></li>
<li><a href="Input/Gaze.html">Gaze</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Microsoft/MixedRealityToolkit-Unity/blob/mrtk_development/Documentation.ja/README_Solver.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
