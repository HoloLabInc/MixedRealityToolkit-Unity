<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Interactable | Mixed Reality Toolkit Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Interactable | Mixed Reality Toolkit Documentation ">
    <meta name="generator" content="docfx 2.45.1.0">
    
    <link rel="shortcut icon" href="../Documentation/Images/favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../Documentation/Images/mrt_logo_icon.png" alt="">
              </a>
            </div>
          
          <div class="version-dropdown" id="versionDropdown">
           </div>
         
          <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="interactable">Interactable</h1>

<p><img src="Images/Interactable/InteractableExamples.png" alt="Interactable"></p>
<p>With Interactable script, you can make any object interactable with differentiated visual state. For example, you can change color of the object on focus or make it bigger on pressed state. Since you can have multiple themes that control different parts of the object, you can achieve sophisticated visual states including shader property changes. In fact, most <a href="README_HandInteractionExamples.html">interaction example scenes</a> revolve around interactions based on Interactables.</p>
<h2 id="how-to-use-interactables">How to use interactables</h2>
<p>Simply add the <a href="https://github.com/Microsoft/MixedRealityToolkit-Unity/blob/mrtk_release/Assets/MixedRealityToolkit.SDK/Features/UX/Scripts/Interactable.cs"><code>Interactable.cs</code></a> component to a GameObject.</p>
<p><img src="Images/Interactable/InteractableInspector_basicSteps.png" alt="Interactable"></p>
<ol>
<li>A collider must exist on the GameObject with the interactable or the child of the interactable for it to receive input.</li>
<li>Use the <em>OnClick</em> event to make something happen.</li>
<li>Add visual feedback by linking a target to a profile and assigning a theme.</li>
</ol>
<p>Interactable features can be extended using external components like <code>PhysicalPressEventRouter</code> which enables press events to drive some state changes in the interactable.</p>
<h2 id="input-settings">Input settings</h2>
<p>The basic features allow for button style interactions, such as pointer focus and clicks, that maps to interaction states to drive themes which are setup through the interactable profile. Controller or hand focus, down, up and click (both near and far) are handled. Functionality can be extended using external scripts that can set state manually.</p>
<img src="Images/Interactable/InputFeatures_short.png" width="450">
<p><strong>Input Actions</strong></p>
<p>Select the action, from the input configuration or controller mapping profile, that the interactable should react to.
See <a href="Input/Overview.html">Overview of the input system in MRTK</a> for more on how input actions are setup and intended to be used in the application.</p>
<p><strong>Enabled</strong></p>
<p>Sets the interactables enabled state, which will disable some input handling and update the themes to reflect the current state which is disabled.</p>
<p>This is different from disabling input all together (using <em>Enable Input</em>). It means that a specific button that would normally be interactive will be disabled and has a visual look and feel to denote its disabled state. A typical example of this would be a submit button waiting for all the required input fields to be completed.</p>
<p><strong>IsGlobal</strong></p>
<p>Focus is not required to detect input actions, default behavior is false.</p>
<p><strong>Voice Commands</strong></p>
<p>Select a Speech Command that has been setup in the MRTK Speech Commands Profile to trigger an OnClick event. This will also provide an automated Focus and Press state change to drive any theme feedback.</p>
<p><strong>Requires Focus (Only available when a speech command is selected)</strong></p>
<p>The voice command requires the interactable to have focus to listen for the voice command. There are several ways to use voice commands to trigger an interactable, be careful not to have multiple objects with the same voice command or there will be conflicts. Using the MRTK voice recognition profile or online speech service are other ways to enable voice commands.</p>
<p><strong>Selection Mode</strong></p>
<p>The ability to add multiple layers to Themes to create controls like Toggles or multi-dimensional (sequential) buttons. <em>See Creating Toggles.</em></p>
<p><strong>Public Properties</strong></p>
<p>ClickCount - a read only value that tracks how many clicks have occurred.</p>
<h2 id="profiles-and-themes">Profiles and Themes</h2>
<p>The profile will define how button content will be linked to and manipulated by themes, based on state changes.</p>
<img src="Images/Interactable/Profiles_noTarget.png" width="450">
<p>Themes work a lot like materials. They are scriptable objects that contain a list of data that will be assigned to an object based on the current state. Like materials, they can be edited individually in the project panel or through the interactable profile. Editing a theme through an interactable will update its settings for all other interactables using that theme. Themes can be extended to control any aspect of a GameObject with a few basic themes provided that can change color, scale, position or an combination of the three.</p>
<img src="Images/Interactable/DefaultTheme_button.png" width="450">
<p>A default theme will be provided whenever an target object is added to a profile. It is not advised to edit the default theme, like in the case MRTK is updated, the theme could get overridden. A &quot;Create Theme&quot; button is provided whenever the default theme is used to make it easier to create a new themes.</p>
<img src="Images/Interactable/DefaultTheme_values.png" width="450">
<p><em>Example of the Default Theme</em></p>
<img src="Images/Interactable/Theme.png" width="450">
<p><em>Example of a Color Theme</em></p>
<p>The best way to save a profile of a button, with all the themes and targets setup, is to create a prefab of your button.
Note that themes that manipulate mesh objects (color or shader themes) are able to detect the shader properties in the material assigned to the target object. A drop down list of shader properties will define how the values of the theme are applied and is a convenience of this ability. Conflicts can arise if the same theme is used on objects that do not share the same material shader setting. Best practice is to create a separate theme for objects with different shaders; this is not an issue when using the same color theme on a text object and a mesh object, because all the shader properties are ignored on text objects.</p>
<h3 id="creating-toggles-and-multi-dimension-buttons">Creating Toggles and Multi-Dimension buttons</h3>
<p>Toggle or multi-dimension buttons can be created in the Profile using the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.SelectionModes.html"><code>Selection Mode</code></a> field. In the Toggle mode, a new toggled theme is added for each Target in the Profile. When the Interactable is toggled on, the Toggled Theme will be used to provide an additional layer of visual feedback.</p>
<p>While the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.SelectionModes.html"><code>Selection Mode</code></a> is set to Toggle, the Is Toggled check box can be used to set the default value of the control which will be visible during runtime.</p>
<p>In the Toggle selection mode, Set the Interactable's toggled state during runtime by calling the Interactable's SetToggled(bool toggle) method to switch the IsToggled state and update the profile to use the correct theme.</p>
<img src="Images/Interactable/Profile_toggle.png" width="450">
<p>Multi-Dimension selection mode is used to create sequential buttons, or a button that has more than two steps, like controlling speed with three values, Fast (1x), Faster (2x) or Fastest (3x).</p>
<img src="Images/Interactable/Profile_multiDimensions.png" width="450">
<p>With dimensions being a numeric value, up to 9 themes can be added to control the text label or texture of the button for each speed setting, using a different theme for each of step.</p>
<p>Developers can assess the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.Interactable.html"><code>DimensionIndex</code></a> to determine which dimension is currently active.</p>
<pre><code class="lang-csharp">//Access the current DimensionIndex
GetDimensionIndex();

//Set the DimensionIndex - toggled
SetDimensionIndex(1);

//Set the DimensionIndex - Untoggled
SetDimensionIndex(0);
</code></pre>
<p>Every click event will advance the DimensionIndex which will increase until the set Dimensions value is reached then cycle or reset to 0. A good example of working with Dimensions with code is the InteractiveToggleCollection found in the InteractableExamples demo scene on the RadialSet object.</p>
<img src="Images/Interactable/InteractableToggleCollection.png" width="450">
<p><strong>See the Events section to learn about Toggle Events.</strong></p>
<h2 id="events">Events</h2>
<p>You can use Interactable to detect input events other than just OnClick. The Events feature provides a way to enable functionality to extend a button, but not really visual or needed to provide feedback based on state changes.</p>
<img src="Images/Interactable/Events.png" width="450">
<p><strong>At the bottom of the Interactable component, click the &quot;Add Event&quot; button to reveal additional event options.</strong> A drop down menu contains the current list of supported events like toggle, hold or double tap. The idea of these events is to monitor Interactable state changes and define patterns to detect. When a pattern is detected, an action can be triggered through the inspector or directly in code.</p>
<img src="Images/Interactable/Event_audioClip.png" width="450">
<p><em>Example of audio clip to play on click. There is an audio theme for playing audio clips for each state change, like focus</em></p>
<img src="Images/Interactable/Event_toggle.png" width="450">
<p><em>Example of Toggle events</em></p>
<img src="Images/Interactable/Event_hold.png" width="450">
<p><em>Example of a hold event</em></p>
<img src="Images/Interactable/Event_onClickEffect.png" width="450">
<p><em>Example of a modified OnClick event to spawn a gameObject on click</em></p>
<p>Events can be placed on an object to monitor a separate interactable. Use <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.InteractableReceiver.html"><code>InteractableReceiver</code></a> for a single event (from the list) or <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.InteractableReceiverList.html"><code>InteractableReceiverList</code></a> for a list of events similar to the interactable event list.</p>
<img src="Images/Interactable/InteractableReceiver.png" width="450">
<p><em>Example of InteractableReceiver existing on a separate gameObject from the Interactable, referencing the Interactable for event and state updates</em></p>
<p>&quot;Search Scope&quot; provides a preferred path to search for an Interactable if one is not explicitly assigned.</p>
<h2 id="states">States</h2>
<p>States are a list of terms that can be used to define interactions phases, like press or observed.</p>
<img src="Images/Interactable/DefaultStates.png" width="450">
<p>Interactable states provide two major roles:</p>
<ul>
<li>Establish a list of states that are relevant for the Interactable. This list will be displayed in the themes and can also be referenced by the events.</li>
<li>Controls how different interaction phases are ranked into states. For instance, a press state is also in a focused state, but the InteractableStates class will define it is a press state based on the ranking preferences setup in the State ScriptableObject.</li>
</ul>
<img src="Images/Interactable/StatesScriptableObject.png" width="450">
<p>The InteractableStates State Model will handle any state list with a layered ranking system, starting with the most isolated state and ending with the state that could contain all other states.</p>
<p>The DefaultInteractableStates list contains 4 states:</p>
<ul>
<li><p><strong>Default</strong>: Nothing is happening, this is the most isolated base state. If anything does happen, it should over rule this state.</p>
</li>
<li><p><strong>Focus</strong>: The object is being pointed at. This is a single state, no other states are currently set, but it will out rank Default.</p>
</li>
<li><p><strong>Press</strong>: The object is being pointed at and a button or hand is pressing. The Press state out ranks Default and Focus. This state will also get set as a fallback to Physical Press.</p>
</li>
<li><p><strong>Disabled</strong>: The button should not be interactive and visual feedback will let the user know for some reason this button is not usable at this time. In theory, the disabled state could contain all other states, but when Enabled is turned off, the Disabled state trumps all other states.</p>
</li>
</ul>
<p>A bit value (#) is assigned to the state depending on the order in the list.</p>
<p>There are currently 17 states total that you can used to drive themes, though some are meant to be driven by other components. Here's a list of those with built-in functionality.</p>
<ul>
<li>Default, Focus, Pressed and Disabled are mentioned above</li>
<li>Visited: the Interactable has been clicked.</li>
<li>Toggled: The button is in a toggled state or Dimension index is an odd number.</li>
<li>Gesture: The hand or controller was pressed and has moved from the original position.</li>
<li>VoiceCommand: A speech command was used to trigger an Interactable.</li>
<li>PhysicalTouch: A touch input is currently detected, use NearInteractionTouchable to enable.</li>
<li>Grab: A hand is currently grabbing in the bounds of the object, use NearInteractionGrabbable to enable</li>
</ul>
<p>States have corresponding properties and Methods in the Interactable, like SetFocus(bool focus) or HasFocus.</p>
<h2 id="interactable-goals-and-architecture">Interactable goals and architecture</h2>
<img src="Images/Interactable/Interactable_overview.png" width="750">
<img src="Images/Interactable/Interactable_details.png" width="1450">
<h2 id="extending-themes">Extending themes</h2>
<p>Extend <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.InteractableThemeBase.html"><code>InteractableThemeBase</code></a> to create a new theme that will show up in the theme property drop-down list. Themes can be created to control anything based on state changes. We could have a custom component on a GameObject that is driven by a custom theme with the values for each state being set in the inspector.</p>
<p>Setup the configuration of the theme settings in the constructor.</p>
<pre><code class="lang-csharp">public NewCustomTheme()
{
    Types = new Type[] { typeof(Transform) };
    Name = &quot;Custom Theme Scale&quot;;
    ThemeProperties.Add(
        new InteractableThemeProperty()
        {
            Name = &quot;Scale&quot;,
            Type = InteractableThemePropertyValueTypes.Vector3,
            Values = new List&lt;InteractableThemePropertyValue&gt;(),
            Default = new InteractableThemePropertyValue() { Vector3 = Vector3.one}
        });
}
</code></pre>
<ul>
<li><p><strong>Name</strong>: The display name of the property, this will display next to the property field under each state title.</p>
</li>
<li><p><strong>Types</strong>: Allow filtering based on components on the object. In this case, this theme will show up in the list when assigned to an object with a Transform.</p>
</li>
<li><p><strong>Name</strong>: The name that will show up in the inspector.</p>
</li>
<li><p><strong>ThemeProperties</strong>: A list of properties that theme will store to be used when the state changes.</p>
</li>
</ul>
<p>Each Theme Property has a name, type (defining the fields to display for each state), a set of values for each state and a default value for the fields. The state fields can also be hidden in the inspector, if the theme does not require them to be visible.</p>
<pre><code class="lang-csharp">    // custom settings will appear in the configuration section of the theme inspector
    // expose properties to allow more customization to the theme
    CustomSettings = new List&lt;InteractableCustomSetting&gt;()
    {
        new InteractableCustomSetting()
        {
            Name = &quot;ScaleMagnifier&quot;,
            Type = InteractableThemePropertyValueTypes.Vector3,
            Value = new InteractableThemePropertyValue() { Vector3 = Vector3.one }
        }
    };

</code></pre>
<p>Override Init to run any startup code, that needs references to the Host GameObject.</p>
<pre><code class="lang-csharp">public override InteractableThemePropertyValue GetProperty(InteractableThemeProperty property)
{
    InteractableThemePropertyValue start = new InteractableThemePropertyValue();
    start.Vector3 = Host.transform.localScale;
    return start;
}
</code></pre>
<p>GetProperty should grab the current property of the Host. This will be used for animation later. Property is provided in case the current value depends on a cached property value. In the example below on the current scale.</p>
<pre><code class="lang-csharp">public override void SetValue(InteractableThemeProperty property, int index, float percentage)
{
    Host.transform.localScale = Vector3.Lerp(property.StartValue.Vector3, property.Values[index].Vector3, percentage);
}
</code></pre>
<p>The SetValue function is used to set the property value based on the current state.</p>
<ul>
<li><p><strong>Property</strong>: A list of property values per state, set through the theme inspector.</p>
</li>
<li><p><strong>Index</strong>: Correlates to the current state.</p>
</li>
<li><p><strong>Percentage</strong>: A float value between 0 and 1. It will be the eased value if an Animation curve is used.</p>
</li>
</ul>
<p>Custom Settings added to the new class will also be displayed in the inspector. If there are properties that need to be exposed in the inspector but do not need to be based on states, they should be added to the Custom Settings list.</p>
<h3 id="extending-shader-themes">Extending shader themes</h3>
<p>If creating a custom interactable theme to modify shader properties, it is advised to extend the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.InteractableShaderTheme.html"><code>InteractableShaderTheme</code></a> class. Please see the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.InteractableColorTheme.html"><code>InteractableColorTheme</code></a> class as an example to extend the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.InteractableShaderTheme.html"><code>InteractableShaderTheme</code></a> class.</p>
<p>Regardless of whether extending the <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.InteractableShaderTheme.html"><code>InteractableShaderTheme</code></a> class or not, it is highly recommended to set shader properties 1) via <a href="https://docs.unity3d.com/ScriptReference/MaterialPropertyBlock.html"><code>MaterialPropertyBlock</code></a> and 2) using the shader properties integer keys instead of string keys. Unity assigns integer keys for all shader properties in a project at runtime.See <a href="https://docs.unity3d.com/ScriptReference/Shader.PropertyToID.html"><code>Shader.PropertyToID</code></a> for more details on. The integer key for an interactable property can be accessed via  <code>InteractableThemeProperty.GetShaderPropertyId()</code>.</p>
<p>Both of these two steps will help with performance. <a href="https://docs.unity3d.com/ScriptReference/MaterialPropertyBlock.html"><code>MaterialPropertyBlock</code></a> will ensure a new material instance is not created for every object modifying a shader property and integer shader property IDs will eliminate the string-to-int lookup step performed by Unity when using string keys (i.e &quot;_Color&quot;) on set/get functions.</p>
<pre><code class="lang-csharp">public override void SetValue(InteractableThemeProperty property, int index, float percentage)
{
     renderer.GetPropertyBlock(propertyBlock);

     int propId = property.GetShaderPropertyId();

     Color newColor = Color.Lerp(property.StartValue.Color, property.Values[index].Color, percentage);
     block.SetColor(propId, color);

     renderer.SetPropertyBlock(propertyBlock);
 }
</code></pre>
<h2 id="extending-events">Extending events</h2>
<p>Like Themes, events can be extended to detect any state pattern or to expose functionality.</p>
<p>Custom events can be created and used in two main ways:</p>
<ul>
<li>Extend <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.ReceiverBase.html"><code>ReceiverBase</code></a> to create a custom event that will show up in the dropdown list of event types. A Unity event is provided by default, but additional Unity events can be added or the event can be set to hide Unity events. This functionality allows a designer to work with an engineer on a project to create a custom event that the designer or implementer to setup in the editor.</li>
<li>Extend <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.ReceiverBaseMonoBehavior.html"><code>ReceiverBaseMonoBehavior</code></a> to create a completely custom event component that can reside on the interactable or another object. The <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.ReceiverBaseMonoBehavior.html"><code>ReceiverBaseMonoBehavior</code></a> will reference the interactable to detect state changes. This approach is the most direct for engineers that do not want to work through the inspector.</li>
</ul>
<h3 id="example-for-extending-receiverbase">Example for extending <code>ReceiverBase</code></h3>
<p><code>MixedRealityToolkit.Examples</code> contains an example extension of ReceiverBase to display status information about the interactable.</p>
<pre><code class="lang-csharp">public CustomInteractablesReceiver(UnityEvent ev) : base(ev)
{
    Name = &quot;CustomEvent&quot;;
    HideUnityEvents = true; // hides Unity events in the receiver - meant to be code only
}
</code></pre>
<p><em>OnUpdate</em> is an abstract method that can be used to detect patterns. Here is an example of accessing all the states of the interactable. Though there is a definite state that is defined with <code>state.CurrentState()</code>, the state object has a reference to all other states and their values.</p>
<pre><code class="lang-csharp">public override void OnUpdate(InteractableStates state, Interactable source)
{
    if (state.CurrentState() != lastState)
    {
        // the state has changed, do something new
        /*
            bool hasDown = state.GetState(InteractableStates.InteractableStateEnum.Pressed).Value &gt; 0;
            bool focused = state.GetState(InteractableStates.InteractableStateEnum.Focus).Value &gt; 0;
            bool isDisabled = state.GetState(InteractableStates.InteractableStateEnum.Disabled).Value &gt; 0;
            bool hasInteractive = state.GetState(InteractableStates.InteractableStateEnum.Interactive).Value &gt; 0;
            bool hasObservation = state.GetState(InteractableStates.InteractableStateEnum.Observation).Value &gt; 0;
            bool hasObservationTargeted = state.GetState(InteractableStates.InteractableStateEnum.ObservationTargeted).Value &gt; 0;
            bool isTargeted = state.GetState(InteractableStates.InteractableStateEnum.Targeted).Value &gt; 0;
            bool isToggled = state.GetState(InteractableStates.InteractableStateEnum.Toggled).Value &gt; 0;
            bool isVisited = state.GetState(InteractableStates.InteractableStateEnum.Visited).Value &gt; 0;
            bool isDefault = state.GetState(InteractableStates.InteractableStateEnum.Default).Value &gt; 0;
            bool hasGesture = state.GetState(InteractableStates.InteractableStateEnum.Gesture).Value &gt; 0;
            bool hasGestureMax = state.GetState(InteractableStates.InteractableStateEnum.GestureMax).Value &gt; 0;
            bool hasCollision = state.GetState(InteractableStates.InteractableStateEnum.Collision).Value &gt; 0;
            bool hasPhysicalTouch = state.GetState(InteractableStates.InteractableStateEnum.PhysicalTouch).Value &gt; 0;
            bool hasCustom = state.GetState(InteractableStates.InteractableStateEnum.Custom).Value &gt; 0;
            or:
            bool hasFocus = source.HasFocus;
            bool hasPress = source.HasPress;
        */
        lastState = state.CurrentState();
        SetOutput();
    }
}
</code></pre>
<p>Two interactable event methods are also available if driving functionality from <em>OnClick</em> or <em>OnVoiceCommand</em> is needed.</p>
<pre><code class="lang-csharp">public virtual void OnVoiceCommand(InteractableStates state, Interactable source, string command, int index = 0, int length = 1)
{
    // voice command called
}  
public virtual void OnClick(InteractableStates state, Interactable source, IMixedRealityPointer pointer = null)
{
    // click called
}
</code></pre>
<p>ReceiverBase scripts use InspectorField attributes to expose custom properties in the inspector. Here's an example of Vector3 a custom property with tooltip and label information.</p>
<pre><code class="lang-csharp"> [InspectorField(Label = &quot;Offset Position&quot;, Tooltip = &quot;Spawn the prefab relative to the Interactive position&quot;, Type = InspectorField.FieldTypes.Vector3)]
        public Vector3 EffectOffset = Vector3.zero;
</code></pre>
<h2 id="extending-states">Extending states</h2>
<p>The functionality of how states are ranked can be overridden by extending <a class="xref" href="../api/Microsoft.MixedReality.Toolkit.UI.InteractableStates.html"><code>InteractableStates</code></a> class. Override the <code>CompareStates</code> method to manually control the ranking.</p>
<pre><code class="lang-csharp">public override State CompareStates()
{
    int bit = GetBit();
    currentState = stateList[0];
    for (int i = stateList.Count - 1; i &gt; -1; i--)
    {
        if (bit &gt;= stateList[i].Bit)
        {
            currentState = stateList[i];
            break;
        }
    }
    return currentState;
}
</code></pre>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="README_MRTKStandardShader.html">MRTK Standard Shader</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Microsoft/MixedRealityToolkit-Unity/blob/mrtk_development/Documentation/README_Interactable.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
